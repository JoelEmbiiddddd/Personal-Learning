## Java内存区域

Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。： 本地内存、线程私有、线程共享



### 运行时的数据区域

线程共享:堆、方法区

线程私有：程序计数器、本地方法栈、虚拟机栈

本地内存：直接内存



在JDK1.8中，线程共享的堆放到了本地内存中了。



### 程序计数器：

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

程序计数器是唯一一个不会出现OOM的内存区域。



### **Java虚拟机栈**

方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。

栈内还是由一个个栈帧组成：

1. 局部变量表：存放着编译器可知的各种数据类型，对象引用等等。
2. 操作数栈：方法调用的中转站，用于存放执行过程中产生的中间计算结果。
3. 动态链接：当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 **动态连接** 。

java虚拟机栈可能出现的问题：

1. `StackOverFlowError:`栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError` 错误。
2. `outOfMemory:`如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。



### **本地方法栈**

和虚拟机栈所发挥的作用非常相似，区别是：**虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。**



### **堆**

**堆内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

Java 堆是垃圾收集器管理的主要区域，因此也被称作 **GC 堆**

在JDK8之前，堆内存主要分为3部分：

1. 新生代
2. 老生代
3. 永生代

**JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存。**

堆中容易出的问题就是OOM：

1. **`GC Overhead Limit Exceeded`**：当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
2. **`Java heap space`**：假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。



### **方法区**

方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。

当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 **类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。



**方法区和永生代和元空间的区别就是**

永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式



**为什么要将永生代替换成元空间？**

1. 永生代有一个JVM本身设置的固定大小上限，无法进行调整。而元空间使用的是本地内存，本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。
2. 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。
3. 在JDK8中，合并HotSpot和JRockit（也是Java一个专有的虚拟机）的代码时，JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。



方法区常见的参数

1. MetaspaceSize=N： 元空间初始大小

2. MaxMetaspaceSize：元空间最大大小

   



### 运行时常量池

Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 **常量池表(Constant Pool Table)** 。常量池表会在类加载后存放到方法区的运行时常量池中。

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 `OutOfMemoryError` 错误。



### 字符串常量池

**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。



**JDK 1.7 为什么要将字符串常量池移动到堆中？**

主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。



### 直接内存

JDK1.4 中新加入的 **NIO（Non-Blocking I/O，也被称为 New I/O）**，引入了一种基于**通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据**。



## HotSpot虚拟机



### 对象的创建

1. 类加载检查

   - 虚拟机遇到一条new指令时，会先去检查这个指令的指数是否能在常量池中找到这个类的符号引用，并且检查这个符号引用代表的类是否已经被加载过、解析和初始化过了。如果没有，则必须先执行相应类的加载过程。

2. 分配内存

   - **类加载检查完成后，为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**

   - **分配的方法有“指针碰撞”和“空闲列表”，选择哪种分配方式由Java堆来规整决定。java堆的规整情况又由垃圾收集器是否带有压缩整理来决定。**

     - 指针碰撞：
       - 适合场景：堆内存规整的情况下。
       - 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
       - 分配方式的GC收集器：serial，ParNew
     - 空闲列表：
       - 适合场景：堆内存不规整的情况下。
       - 原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配时，找一块足够大的内存块来划分给对象实例，最后更新列表记录
       - GC收集器：CMS

   - **内存分配并发问题**：

     在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

     - CAS+失败重试：**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
     - TLAB：为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。

3.  初始化零值

   内存分配完成后，虚拟机需要将分配到的内存空间初始化为零。这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用。

4. 设置对象头

   - 初始化完成后，虚拟机对对象进行初始化。例如这个对象是哪个类的实例、对象的hash码，对象的GC分代年龄信息等等。

5. 执行init方法

   - 从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

     

### 对象内存布局

在JAVA Hotspot中，对象在内存中的布局分为：**对象头、实例数据和对齐填充**

1. Hotspot对象头包含有两部分信息：
   - 第一部分用于存储自身的信息
   - 类型指针：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
2. 实例数据是对象真正存储的有效信息：
3. 对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用:因为在Java Hotspot中，对象的大小必须是 8 字节的整数倍



## JVM垃圾回收

**元空间使用的是直接内存** 。



### 对象内存分配和回收原则

1. 对象优先在Eden区分配：大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。如果gc后还是不行，就会放在老年代中。
2. 大对象直接进入老年代中：大对象直接进入老年代主要是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。
3. 长期存活的对象将进入老年代：



虚拟机采取了分代收集的思想，给每个对象一个对象年龄计数器



**具体的流程可以是这样子的：**

1. 大部分情况下（除了大对象），对象会先在Eden区域分配，如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1。
2. Survivor中每熬过一次GC年龄就会加1岁，当到了15岁后，就会移动到老生代中。15岁的阈值是可以通过MaxTenuringThreshold来设置的。



### 主要进行GC的区域：

针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：

部分收集 (Partial GC)：

- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

整堆收集 (Full GC)：收集整个 Java 堆和方法区。



### 空间分配担保

空间分配担保是为了确保在Minor GC之前 老年代本身还有容纳新生代所有对象的剩余空间。只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。



## 死亡对象判断方法



### 引用计数器

给对象添加一个引用计数器。

使用加1，释放减1，为0则销毁

**但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。**

对象之间的相互引用问题，如下面代码所示：除了对象 `objA` 和 `objB` 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。



### 可达性分析算法

通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。

**哪些对象会被当作GC Roots**

1. 虚拟机栈中引用的对象
2. 方法区常量引用对象
3. 方法区静态属性引用对象
4. 本地方法栈中引用的对象



**可达性分析中不可达的对象，代表一定会被回收吗？**

宣告一个对象的死亡，主要经历2次标记过程

1. 第一次发现没有链接，标记。
2. 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。



### 引用类型



1. 强引用：垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。
2. 软引用：如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。
3. 弱引用：和软引用一样。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。
4. 虚引用：虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收
   - 用来跟踪对象被垃圾回收的活动
   - **虚引用与软引用和弱引用的一个区别在于：**



## 垃圾回收算法



### 标记-清除算法

首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。

**存在问题**

1. 效率问题：标记和清理两个过程效率不高。
2. 空间问题：标记清楚后会产生大量不连续的内存碎片。



**具体流程：**

1. 当一个对象被创建时，给一个标记位，假设为 0 (false)；
2. 在标记阶段，我们将所有可达对象（或用户可以引用的对象）的标记位设置为 1 (true)；
3. 扫描阶段清除的就是标记位为 0 (false)的对象。



### 复制算法

将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

**存在问题：**

1. 可用内存变小：为原来的一半。
2. 不适合老年代：如果存活对象很多，那么整个复制性能会变得很差。



### 标记整理法

具体流程和标记清理一样。

根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。



**存在问题**

由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。



### 分代收集算法

当前虚拟机的垃圾收集都采用分代收集算法。根据新生代和老年代选择不同的垃圾收集算法。

**新生代：** 标记-复制算法

**老生代：** 标记清理或标记整理



## 垃圾回收器

- DK 8：Parallel Scavenge（新生代）+ Parallel Old（老年代）
- JDK 9 ~ JDK20: G1



### 目前所有垃圾回收器存在有什么问题

迄今为止，所有垃圾收集器在根节点枚举这一步骤时都是必须暂停用户线程的，因此毫无疑问会面临 ”Stop The World“ 的困扰。啊？啥是 ”Stop The World“，也就是我们平时说的 STW，其实就是根节点枚举过程中必须在一个能保障一致性的快照中进行，说白了就相当于持久化的快照一样，在某个时间点这个过程像被冻结了。如果根节点枚举过程中整个根节点集合对象引用关系还在变化，那垃圾回收分析的结果也不会准确，所以这就导致垃圾收集过程中必须停顿所有用户线程。



### Serial收集器

新生代采用标记-复制算法，老年代采用标记-整理算法

Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。



### ParNew收集器

ParNew 收集器其实就是 Serial 收集器的多线程版本



### Parallel Scavenge收集器

Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器。提供了很多参数供用户找到最合适的停顿时间或最大吞吐量。也可以使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。

**新生代采用标记-复制算法，老年代采用标记-整理算法。**



### Serial Old 收集器

Serial 收集器的老年代版本，它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。



### Parallel Old收集器

**Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。



### CMS收集器

**CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。** 实现了垃圾收集线程和用户线程同时工作。



CMS收集器是一种"标记-清除"算法实现的。

1. 初始标记：暂停所有其他线程，并记录下直接与root相连的对象。
2. 并发标记：同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但并没有在结束的时候包含当前所有的可达对象。
3. 重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。
4. 并发清除：开启用户线程，同时 GC 线程开始对未标记的区域做清扫。



**存在缺点：**

1. 对cpu资源敏感。
2. 无法处理浮动垃圾
3. 使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。



### G1收集器

是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征。

G1采用了分区(Region)的思路，将整个堆空间分成若干个大小相等的内存区域，每次分配对象空间将逐段地使用内存。

**具体特点：**

1. 并行和并发：使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
2. 分代收集：
3. 空间整合： CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。
4. 可预测停顿：G1建立了一个可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。



**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region**，可以保证了 G1 收集器在有限时间内可以尽可能高的收集效率



### G1和CMS的停顿时间瓶颈

标记复制法应用在CMS新生代和G1垃圾回收器中，标记复制法可以分为三个阶段：

1. 标记阶段，从GC Roots集合开始，标记活跃对象。
2. 转移阶段，把活跃对象转移到新的内存地址上。
3. 重定位阶段。指针调回到对象新的地址上。



**标记阶段的STW**

1. **初始标记阶段：**从GC Root集出发，标记全部子节点。但是STW时间很短。
2. **再标记阶段**：重新标记那些在并发标记阶段发生变化的对象。该阶段是STW的。



**清理阶段停顿STW**

1. **清理阶段**清点出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制。该阶段是STW的。



**复制阶段停顿分析**

1. **复制算法**中的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是STW的



**G1停顿时间的瓶颈主要是标记-复制中的转移阶段STW**。为什么转移阶段不能和标记阶段一样并发执行呢？主要是G1未能解决转移过程中准确定位对象地址的问题。





### 三色标记算法（基于可达性分析的 GC 算法，G1和GMS都使用了）

首先，事先约定好：

1. **白色：**表示对象尚未被垃圾回收器访问过，如果在可达性分析后，仍然是白色，就代表是不可达的。
2. **灰色：**表示对象已经被垃圾回收器访问过，但至少存在一个以上的对象没有被扫描过。
3. **黑色：**表示对象已经被垃圾收集器回收过了，而且这个对象的所有引用都被扫描过。

[阿里二面：JVM 的三色标记算法你了解吗？ - 掘金 (juejin.cn)](https://juejin.cn/post/6979249945551339551)

三色标记算法也存在缺陷，在并发标记阶段的时候，因为用户线程与 GC 线程同时运行，有可能会产生多标或者漏标。

1. 多标：在多并发状态下容易出错。
2. 漏标：漏标只有同时满足两个条件才会发生
   - 一个或者多个黑色对象重新引用了白色对象；即黑色对象成员变量增加了新的引用。
   - 灰色对象断开了白色对象的引用（直接或间接的引用）；即灰色对象原来成员变量的引用发生了变化。



改进方法：

对于读写屏障，以 Java HotSpot VM 为例，其并发标记时对漏标的处理方案如下：

- `CMS`：写屏障 + 增量更新
- `G1、Shenandoah`：写屏障 + 原始快照
- `ZGC`：读屏障



### Shenandoah

Shenandoah 的目标是将垃圾回收的停顿时间控制在 10ms 以内，这意味着 Shenandoah 不仅需要在并发标记阶段实现并发，还需要在标记清除阶段实现并发。

Shenandoah可以看作是G1的改良版。同样采用了基于Region的内存布局，在标记阶段均采用了并发标记。

1. 回收阶段，采用的是并发整理，由于和用户线程并发执行，因此这一过程不会造成 STW。
2. 默认情况下不使用分代收集，也就是 Shenandoah 不会专门设计新生代和老年代，因为 Shenandoah 认为对对象分代的优先级并不高，不是非常有必要实现。
3. 采用“连接矩阵”代替记忆集。在 G1 以及其他经典垃圾回收器中均采用了记忆集来实现跨分区或者跨代引用的问题，每个 Region 中都维护了一个记忆集，浪费了很多内存，且导致系统负载也更重。

连接矩阵可以理解为一个二维数组，当 Region N 的对象引用了 Region M 中的对象，那么就将二维数组 array[N][m]设置一个标志位。



步骤：

1. 和G1一样，初始标记、并发标记、最终标记。
2. 并发清理。这一步和 G1 就不同了，G1 中是多个 GC 线程并行清理，而 Shenandoah 中是并发清理，GC 线程和用户线程并发执行，不会造成 STW。
3. 并发回收。将回收集中，所有存活的对象复制到空闲的 Region 中，这一步也是并发执行，不会造成 STW，执行时间的长短与回收集的大小以及存活对象的数量相关。**使用的是复制方法**，但采用复制方法也容易出问题，因为复制是要需要修改存活对象的引用指向的。使用了**Brooks Pointers**来改进。
4. 引用更新。该阶段就是让堆中所有指向旧对象的地址修正为指向新地址。
5. 并发清理。





### ZGC

是在JDK11推出的一款低延迟垃圾回收器。

**ZGC在标记、转移和重定位阶段几乎都是并发**的（应用程序和垃圾回收是同时进行），这是ZGC实现停顿时间小于10ms目标的最关键原因。



**应用程序和垃圾回收的问题是什么？**

并发转移中“并发”意味着GC线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。

**ZGC的解决方法：**

应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。那么，JVM是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针。下面介绍着色指针和读屏障技术细节。











## 类文件加载过程

整个生命周期可以分为7阶段：

**Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？**

**系统加载 Class 类型的文件主要三步：**加载->连接->初始化**。连接过程又可分为三步：**验证->准备->解析**。**

1. 加载： 通过全类名获取此类的二进制字节流，然后将字节流所代表的的静态存储转化为方法区运行时的数据结构。在内存中生成一个代表该类的`class`对象
2. 验证：用处是确保Class文件的字节流中包含的信息符合全部约束要求。
   - class文件格式检查
   - 字节码语义检查
   - 程序语义检查
   - 类的正确性检查
3. 准备：**正式为类变量分配内存并设置类变量初始值的阶段**。这时候内存分配的仅仅包括类变量，也就是静态变量，而不包括实例变量。
4. 解析：**解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程**。
5. 初始化：**执行初始化方法 `<clinit> ()`方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。**



## 类加载器

- 类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。

- 每个 Java 类都有一个引用指向加载它的 `ClassLoader`。

- 数组类不是通过 `ClassLoader` 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的



简单来说就是**类加载器的主要作用就是加载 Java 类的字节码（ `.class` 文件）到 JVM 中（在内存中生成一个代表该类的 `Class` 对象）。** 



### 类加载器加载规则

1. JVM启动的时候，并不会把所有的类都加载进来，而是动态加载。大部分情况是用到的时候才会去加载。

2. 对于已经加载的类会被放在`ClassLoader`中。首先系统会判断当前类是否被加载。已经被加载的话就会直接返回这个类，否则才会尝试加载。



### 类加载器

JVM中内置了3个重要的`ClassLoader`

1. `BootStrapClassLoader` （启动类加载器）：最顶层的加载类，由C++实现，通知表现为Null，没有父级，用来加载JDK内部的核心类库。比如(runtime.jar)
2. `ExtensionClassLoader`（扩展类加载器）：主要是加载lib目录下的jar包和被dirs系统变量所指定的路径下的所有类。
3. `AppClassLoader`（应用程序类加载器）：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。



除了BootStrapClassLoader是在JVM内部的一部分外，其他都是在JVM外部实现的。并且全都继承自 `ClassLoader`抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。



### 如何判断一个类是由BootStrapClassLoader

每个`ClassLoader`都可以通过`getParent()`获得其父ClassLoader，如果获得的ClassLoader为Null，就代表是BootStrapClassLoader。



### 为什么要有类自定义加载器？

可以自定义类加载器，以满足自己的特殊需求。比如说，我们可以对 Java 类的字节码（ `.class` 文件）进行加密，加载时再利用自定义的类加载器对其解密。



### 自定义类加载器

想要自定义类加载器，就需要我们继承`ClassLoader`抽象类。

`ClassLoader`类有两个关键的方法：

- loadClass：加载指定的二进制类，实现双亲委派机制。
- findclass：根据类的二进制名称来查找类



如果我们不想打破双亲委派模型，就重写`ClassLoader`类中的findClass（）。如果要打破就写loadClass



### 双亲委派模型

类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载呢？这就需要提到双亲委派模型了。



具体来讲就是：

- `ClassLoader` 类使用委托模型来搜索类和资源。

- 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。

- `ClassLoader` 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。



执行流程：

1. 在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。
2. 类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。这样的话，所有的请求最终都会传送到顶层的启动类加载器 `BootstrapClassLoader` 中。
3. 只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 `findClass()` 方法来加载类）。



### **JVM 判定两个 Java 类是否相同的具体规则**

JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。



### 打破双亲委派模型

就是重写LoadClass就好了

我们比较熟悉的 Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器 `WebAppClassLoader` 来打破双亲委托机制。这也是 Tomcat 下 Web 应用之间的类实现隔离的具体原理。