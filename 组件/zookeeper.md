## Zookeeper的简单介绍

Zookeeper是一个开源的分布式协调组件，它的目的就是将复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的、简单易用的接口提供给用户使用。

作用：数据订阅/发布、负载均衡、集群管理、分布式锁、分布式队列。这些功能主要依赖于Zookeeper提供的数据存储+事件监听功能。



### 重要概念

**数据模型：**ZooKeeper 数据模型采用层次化的多叉树形结构，每个节点上都可以存储数据，这些数据可以是数字、字符串或者是二级制序列。

**数据节点：**每个数据节点在zookeeper中被称为是znode，每个znode由2部分组成，分别是stat状态信息、data实际数据。

**版本号：**

**Watcher 事件监听器：**ooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。

**Session：** Zookeeper会和客户端之间维系一个TCP长连接，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向 ZooKeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的 Watcher 事件通知。**会话开始前，Zookeeper会给每个会话分配一个SessionID，保证全局的唯一性。**



## Zookeeper集群

最常见的集群模式是主从模式，主服务器提供写服务，其他从服务器通过异步复制的方式获取主服务器最新的数据并提供读服务。

但在Zookeeper中，没有使用主从模式，而是 **Leader、Follower和observer**。 Follower和observer功能类似，唯一不同的是observer是不能够参与选举的。



### 选举过程

1. 首先是选举阶段，如果一个节点得到超过半数的节点回复，就可以当选准leader。
2. follower会向准leader进行通信，follower同步最近接收的事务提议。
3. 利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后准 leader 才会成为真正的 leader。
4. zookeeper正式对外提供事务服务。



### 什么是集群脑裂、如何防止脑裂

就是在集群里边，多台机器会部署在不同的机房，来提高这个集群的可用性。，但是如果其中一个机房网络出现异常，集群被分割为好几个小集群，这个时候每个小集群各自选举出leader导致脑裂。



在zookeeper中，zookeeper的过半机制导致不可能产生2个leader，因为少于等于一半是不可能产生 leader 的，这就使得不论机房的机器如何分配都不可能发生脑裂。



### 一致性算法和协议

在分布式系统中，整个调用链中，我们所有服务的数据处理要么都成功要么都失败，即所有服务的 **原子性问题** 。

#### 两阶段提交

涉及到两个角色，**协调者和参与者**

1. 执行一个分布式事务的时候，协调者会向所有的参与者发送`prepare`。当参与者收到`prepare`后，他们会开始执行事务（但不提交），并将 `Undo` 和 `Redo` 信息记入事务日志中，之后参与者就向协调者反馈是否准备好了，发送yes or No。
2. 协调组收集到所有参与者的返回信息，都是yes的话，那么就向所有参与者发送`commit`信息，否则就是就要求所有的参与者回滚。然后再将处理情况返回给协调者，最终协调者收到响应后便给事务发起者返回处理失败的结果。

**存在的问题**

1. **单点故障问题：如果协调者挂了整个系统就处于不可用状态**
2. **阻塞问题：** 参与者收到消息后，对事务进行处理但不提交，如果这时候协调者挂了，那么这些资源就不会再释放了。
3. **数据不一致：**当第二阶段，协调者只发送了一部分的 `commit` 请求就挂了，那么也就意味着，收到消息的参与者会进行事务的提交，而后面没收到的则不会进行事务提交，那么这时候就会产生数据不一致性问题。



### 三阶段提交

1. 向所有的参与者发送确认命令，询问是否可以执行事务提交操作，如果全部响应则进入下一阶段。
2. 协调者向所有的参与者再发送一次确认命令，询问是否可以进行事务预提交操作，参与者接收到请求后，如果参与者成功的执行事务操作，则返回yes，否则No，进入最终commit阶段。一旦有一个返回No，则所有的参与者都要进行回滚，终止事务执行。
3. 在前两个阶段中，如果所有的参与者都是Yes，那么协调者则向参与者发送Commit的命令正式提交事务，如果协调者没有接收到参与者的ack响应，则发送终止事务执行指令。

**存在问题：**

1. 3PC是假设机器失败而没有消息失败，现实的情形是，机器失败是无法完美地检测出来的，消息传输可能因为网络拥堵花费很多时间。同时, 说阻塞是相对, 存在协调者和参与者同时失败的情形下, 3PC事务依然会阻塞。



### Paxos算法



#### 准备阶段

`Proposer提案者`：负责提出 `proposal`，每个提案者在提出提案时都会首先获取到一个 **具有全局唯一性的、递增的提案编号 N**，即在整个集群中是唯一的编号 N，然后将该编号赋予其要提出的提案，在**第一阶段是只将提案编号发送给所有的表决者**。

`Acceptor表决者`：每个表决者在 `accept` 某提案后，会将该提案编号 N 记录在本地，这样每个表决者中保存的已经被 accept 的提案中会存在一个**编号最大的提案**，其编号假设为 `maxN`。每个表决者仅会 `accept` 编号大于自己本地 `maxN` 的提案，在批准提案时表决者会将以前接受过的最大编号的提案作为响应反馈给 `Proposer` 。



### 接受阶段

1. 当一个提案被Proposer提出后，如果收到一半以上的批准，那么此时 `Proposer` 会给所有的 `Acceptor` 发送真正的提案（你可以理解为第一阶段为试探），这个时候 `Proposer` 就会发送提案的内容和提案编号。

2. 表决者收到提案请求后会再次比较本身已经批准过的最大提案编号和该提案编号，如果该提案编号 **大于等于** 已经批准过的最大提案编号，那么就 `accept` 该提案（此时执行提案内容但不提交），随后将情况返回给 `Proposer` 。如果不满足则不回应或者返回 NO 。

   

当 `Proposer` 收到超过半数的 `accept` ，那么它这个时候会向所有的 `acceptor` 发送提案的提交请求。

而如果 `Proposer` 如果没有收到超过半数的 `accept` 那么它将会将 **递增** 该 `Proposal` 的编号，然后 **重新进入 `Prepare` 阶段** 。



## Zookeeper协议

这个协议能够很好地支持 **崩溃恢复** 。

 

### ZAB的三个角色

Leader：唯一的写请求处理者

Follower：能够接收客户端请求的人

Observer：就是没有选举权和被选举权的的Follower



### 消息广播模式- 保证顺序性

为了避免 Leader广播了A，有一个节点网络出现问题没收到，然后Leader广播了B，结果这时候节点网络好了，就会先收到B，再收到A，为了避免这种情况发生，Leader段会为每个server准备一个TCP协议的队列，保证消息的顺序。

此外，在 `ZAB` 中还定义了一个 **全局单调递增的事务 ID `ZXID`**，一个递增的事务ID。



### 崩溃模式恢复

针对的问题就是，当集群中有机器挂掉了，我们整个集群如何保证数据一致性？

1. 如果Follower挂了，而且挂的数量没有超过半数，就不用担心。
2. 如果是Leader挂掉了，
3. 需要先暂停服务变为 `Looking` 状态，然后进行 `Leader` 的重新选举（上面我讲过了），但这个就要分为两种情况了，分别是 
   - **确保已经被 Leader 提交的提案最终能够被所有的 Follower 提交** 。
   -  **跳过那些已经被丢弃的提案** 。

解决办法

实际上**`server1` 已经不可能成为 `Leader` 了，因为 `server1` 和 `server3` 进行投票选举的时候会比较 `ZXID` ，而此时 `server3` 的 `ZXID` 肯定比 `server1` 的大了**。



