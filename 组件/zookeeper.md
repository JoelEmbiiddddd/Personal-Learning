## Zookeeper的简单介绍

Zookeeper是一个开源的分布式协调组件，它的目的就是将复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的、简单易用的接口提供给用户使用。

作用：数据订阅/发布、负载均衡、集群管理、分布式锁、分布式队列。这些功能主要依赖于Zookeeper提供的数据存储+事件监听功能。



### 重要概念

**数据模型：**ZooKeeper 数据模型采用层次化的多叉树形结构，每个节点上都可以存储数据，这些数据可以是数字、字符串或者是二级制序列。

**数据节点：**每个数据节点在zookeeper中被称为是znode，每个znode由2部分组成，分别是stat状态信息、data实际数据。

**版本号：**

**Watcher 事件监听器：**ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。

**Session：** Zookeeper会和客户端之间维系一个TCP长连接，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向 ZooKeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的 Watcher 事件通知。**会话开始前，Zookeeper会给每个会话分配一个SessionID，保证全局的唯一性。**



### 分布式锁

Zookeeper的临时节点可以用来实现分布式锁，多个客户端分别创建一个节点，创建成功即成功获取到了锁，创建失败的客户端们则会监听这个临时节点，获取锁的客户端释放锁（删除临时节点）或 与ZK服务端断开连接后（ZK会删除临时节点），其他客户端会收到Watch发来的通知，兄弟们，它释放锁了，你们过来抢占锁吧。



### Watch机制

最原始的分布式锁，惊群效应：当许多进程等待一个事件，事件发生后这些进程被唤醒，但只有一个进程能获得CPU执行权，其他进程又得被阻塞，这造成了严重的系统上下文切换代价。

在一些分布式场景中，我们正常只需要某一台机器参与分布式的工作中。当机器异常宕机后，Zookeeper会利用Watch机制通知其他机器继续来创建临时节点，且只有一台机器能创建成功，那么其他机器又会监听这个节点；而创建节点成功的机器则会代替之前宕机的机器对外提供服务。

**实际我们可以将watch机制看成是分布式常见下的观察者模式**

通常我们在实现观察者模式时，最核心或者说关键的代码就是创建一个列表来存放观察者。 而在 ZooKeeper 中则是在客户端和服务器端分别实现两个存放观察者列表，即：`ZKWatchManager` 和 `WatchManager`。底层是一个`Selector`



#### 客户端watch注册实现过程

当发送一个带有 Watch 事件的请求时，客户端首先会把该会话标记为带有 Watch 监控的事件请求，之后通过 `DataWatchRegistration` 类来保存 **watcher 事件和节点的对应关系**

1. 客户端发送请求首先会将发送信息封装成`Packet`对象

2. 发送时会采用Java NIO/Netty的方式，如果注册了Watch，会向服务端发送Watch信息

3. 发送完成后，客户端通过回调方法获取`ZKWatchManager`中对应的Watch Map ，在Map中注册相关的Watch



#### 服务端Watch注册实现过程

- 当ZooKeeper服务端接收到一个客户端请求时，首先会对请求进行解析，判断该请求是否包含Watch事件，如果包含Watch事件，则将Watch事件存储到`WatchManager`中，该类管理了整个ZK集群的所有watcher。
- 同时将自己 NIOServerCnxn 做为一个 Watcher callback，监听服务端事件变化



#### 服务端Watch事件的触发时机

服务端执行`setData`方法对节点数据进行变更后，会调用 `WatchManager.triggerWatch` 方法触发**数据变更事件**。

- 首先，封装了一个具有会话状态、事件类型、数据节点 3 种属性的 WatchedEvent 对象。

- 之后查询该节点注册的 Watch 事件，如果为空说明该节点没有注册过 Watch 事件。如果存在 Watch 事件则添加到定义的 Watchers 集合中，并在 WatchManager 管理中删除。

- 最后，通过调用 process 方法向客户端发送通知。



#### 客户端回调的处理过程

客户端使用EventThread线程不断轮询处理所有的event事件，如果该事件为watcher类型（服务端的watch通知只会告知那个节点发生了变更，而不会告知其变更具体内容），则从ZKWatchManager查询该节点对应的watcher再次放到一个队列中进行处理（保证了wathcer的顺序执行），执行完后将watcher移除。



#### 应用

1. 配置中心
2. 注册中心







## Zookeeper集群

最常见的集群模式是主从模式，主服务器提供写服务，其他从服务器通过异步复制的方式获取主服务器最新的数据并提供读服务。

但在Zookeeper中，没有使用主从模式，而是 **Leader、Follower和observer**。 Follower和observer功能类似，唯一不同的是observer是不能够参与选举的。



### 选举过程

1. 首先是选举阶段，如果一个节点得到超过半数的节点回复，就可以当选准leader。
2. follower会向准leader进行通信，follower同步最近接收的事务提议。
3. 利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后准 leader 才会成为真正的 leader。
4. zookeeper正式对外提供事务服务。



### 什么是集群脑裂、如何防止脑裂

就是在集群里边，多台机器会部署在不同的机房，来提高这个集群的可用性。，但是如果其中一个机房网络出现异常，集群被分割为好几个小集群，这个时候每个小集群各自选举出leader导致脑裂。



在zookeeper中，zookeeper的过半机制导致不可能产生2个leader，因为少于等于一半是不可能产生 leader 的，这就使得不论机房的机器如何分配都不可能发生脑裂。



### 一致性算法和协议

在分布式系统中，整个调用链中，我们所有服务的数据处理要么都成功要么都失败，即所有服务的 **原子性问题** 。

#### 两阶段提交

涉及到两个角色，**协调者和参与者**

1. 执行一个分布式事务的时候，协调者会向所有的参与者发送`prepare`。当参与者收到`prepare`后，他们会开始执行事务（但不提交），并将 `Undo` 和 `Redo` 信息记入事务日志中，之后参与者就向协调者反馈是否准备好了，发送yes or No。
2. 协调组收集到所有参与者的返回信息，都是yes的话，那么就向所有参与者发送`commit`信息，否则就是就要求所有的参与者回滚。然后再将处理情况返回给协调者，最终协调者收到响应后便给事务发起者返回处理失败的结果。

**存在的问题**

1. **单点故障问题：如果协调者挂了整个系统就处于不可用状态**
2. **阻塞问题：** 参与者收到消息后，对事务进行处理但不提交，如果这时候协调者挂了，那么这些资源就不会再释放了。
3. **数据不一致：**当第二阶段，协调者只发送了一部分的 `commit` 请求就挂了，那么也就意味着，收到消息的参与者会进行事务的提交，而后面没收到的则不会进行事务提交，那么这时候就会产生数据不一致性问题。



### 三阶段提交

1. 向所有的参与者发送确认命令，询问是否可以执行事务提交操作，如果全部响应则进入下一阶段。
2. 协调者向所有的参与者再发送一次确认命令，询问是否可以进行事务预提交操作，参与者接收到请求后，如果参与者成功的执行事务操作，则返回yes，否则No，进入最终commit阶段。一旦有一个返回No，则所有的参与者都要进行回滚，终止事务执行。
3. 在前两个阶段中，如果所有的参与者都是Yes，那么协调者则向参与者发送Commit的命令正式提交事务，如果协调者没有接收到参与者的ack响应，则发送终止事务执行指令。

**存在问题：**

1. 3PC是假设机器失败而没有消息失败，现实的情形是，机器失败是无法完美地检测出来的，消息传输可能因为网络拥堵花费很多时间。同时, 说阻塞是相对, 存在协调者和参与者同时失败的情形下, 3PC事务依然会阻塞。



### Paxos算法



#### 准备阶段

`Proposer提案者`：负责提出 `proposal`，每个提案者在提出提案时都会首先获取到一个 **具有全局唯一性的、递增的提案编号 N**，即在整个集群中是唯一的编号 N，然后将该编号赋予其要提出的提案，在**第一阶段是只将提案编号发送给所有的表决者**。

`Acceptor表决者`：每个表决者在 `accept` 某提案后，会将该提案编号 N 记录在本地，这样每个表决者中保存的已经被 accept 的提案中会存在一个**编号最大的提案**，其编号假设为 `maxN`。每个表决者仅会 `accept` 编号大于自己本地 `maxN` 的提案，在批准提案时表决者会将以前接受过的最大编号的提案作为响应反馈给 `Proposer` 。



### 接受阶段

1. 当一个提案被Proposer提出后，如果收到一半以上的批准，那么此时 `Proposer` 会给所有的 `Acceptor` 发送真正的提案（你可以理解为第一阶段为试探），这个时候 `Proposer` 就会发送提案的内容和提案编号。

2. 表决者收到提案请求后会再次比较本身已经批准过的最大提案编号和该提案编号，如果该提案编号 **大于等于** 已经批准过的最大提案编号，那么就 `accept` 该提案（此时执行提案内容但不提交），随后将情况返回给 `Proposer` 。如果不满足则不回应或者返回 NO 。

   

当 `Proposer` 收到超过半数的 `accept` ，那么它这个时候会向所有的 `acceptor` 发送提案的提交请求。

而如果 `Proposer` 如果没有收到超过半数的 `accept` 那么它将会将 **递增** 该 `Proposal` 的编号，然后 **重新进入 `Prepare` 阶段** 。



## Zookeeper协议

这个协议能够很好地支持 **崩溃恢复** 。

 

### ZAB的三个角色

Leader：唯一的写请求处理者

Follower：能够接收客户端请求的人

Observer：就是没有选举权和被选举权的的Follower



### 保证数据的一致性

**每个session的请求按顺序执行、写请求按照zxid顺序执行、确认一个session中写请求之间没有竞争**



### 消息广播模式- 保证顺序性

为了避免 Leader广播了A，有一个节点网络出现问题没收到，然后Leader广播了B，结果这时候节点网络好了，就会先收到B，再收到A，为了避免这种情况发生，Leader段会为每个server准备一个TCP协议的队列，保证消息的顺序。

此外，在 `ZAB` 中还定义了一个 **全局单调递增的事务 ID `ZXID`**，一个递增的事务ID。



### 崩溃模式恢复

针对的问题就是，当集群中有机器挂掉了，我们整个集群如何保证数据一致性？

1. 如果Follower挂了，而且挂的数量没有超过半数，就不用担心。
2. 如果是Leader挂掉了，
3. 需要先暂停服务变为 `Looking` 状态，然后进行 `Leader` 的重新选举，但这个就要分为两种情况了，分别是 
   - **确保已经被 Leader 提交的提案最终能够被所有的 Follower 提交** 。
   -  **跳过那些已经被丢弃的提案** 。

解决办法

实际上**`server1` 已经不可能成为 `Leader` 了，因为 `server1` 和 `server3` 进行投票选举的时候会比较 `ZXID` ，而此时 `server3` 的 `ZXID` 肯定比 `server1` 的大了**。



