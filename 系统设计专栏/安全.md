## 认证授权基本知识



### 什么是RBAC模型

系统权限控制最常采用的访问控制模型就是 **RBAC 模型** 。实际就是基于角色的权限访问控制。



### Cookies是什么，Session是什么，二者的区别是什么？

`Cookie` 和 `Session` 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。



#### Cookies

Cookies是用来辨别用户身份而储存在用户本地终端的数据。

**应用场景**

1. 可以保存已经登陆过的用户信息，下次登录的时候可以自动登录。还可以保存用户的首选项，主题和其他信息。

2. 使用 `Cookie` 保存 `SessionId` 或者 `Token` ，向后端发送请求的时候带上 `Cookie`，这样后端就能取到 `Session` 或者 `Token` 了。这样就能记录用户当前的状态了，因为 HTTP 协议是无状态的。

3. `Cookie` 还可以用来记录和分析用户行为。举个简单的例子你在网上购物的时候，因为 HTTP 协议是没有状态的，如果服务器想要获取你在某个页面的停留状态或者看了哪些商品，一种常用的实现方式就是将这些信息存放在 Cookie

   

#### Session

那么我们知道Http是不保存状态的协议，也就是Http协议自身不对请求和响应之间的状态进行保存。为了保存用户状态，可以使用session机制，它的主要作用就是通过服务端记录用户的状态。

**应用场景：**购物车场景，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了

如何对Session进行追踪？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。



#### 二者的区别

**`Session` 的主要作用就是通过服务端记录用户的状态。**

`Cookie` 数据保存在客户端(浏览器端)，`Session` 数据保存在服务器端。

相对来说 `Session` 安全性更高。如果使用 `Cookie` 的一些敏感信息不要写入 `Cookie` 中，最好能将 `Cookie` 信息加密然后使用到的时候再去服务器端解密。



### 如何使用Session-Cookies方案进行身份验证

通过 `SessionID` 来实现特定的用户，`SessionID` 一般会选择存放在 Redis 中

1. 当用户登录成功后，返回客户端具有`SessionID`的Cookies。
2. 当用户后端发起请求的时候就会把SessionID给带上。



### 如果没有Cookies了，Session还能用吗？

一般我是通过Cookies来保存SessionID的，如果Cookies被禁了，还是可以用Session的，比如你可以将 `SessionID` 放在请求的 `url` 里面`https://javaguide.cn/?Session_id=xxx` 。这种方案的话可行，但是安全性和用户体验感降低。当然，为了你也可以对 `SessionID` 进行一次加密之后再传入后端





## JWT

JWT是基于Token的认证授权机制，



### 组成部分

JWT本质上就是一组字符串，通过（.）切分成3个Base64编码的部分。

- **Header**：描述JWT的元数据，定义了生成签名的算法以及 `Token` 的类型。
- **Payload：**用来存放实际需要传递的数据。
- **Signature签名：**服务器通过 Payload、Header 和一个密钥(Secret)使用 Header 里面指定的签名算法

Header 和 Payload 都是 JSON 格式的数据，Signature 由 Payload、Header 和 Secret(密钥)通过特定的计算公式和加密算法得到



#### Header

1. type：令牌类型，即jwt
2. alg：签名算法，如HS256



#### Payload

主要包含Claims声明，即JWT接收方、过期时间、签发时间、签发方等等。一般不将隐蔽信息放在Payload中。



#### Signature

对前两部分的签名，作用是防止 JWT（主要是 payload） 被篡改。

- Header + Payload。
- 存放在服务端的密钥(一定不要泄露出去)。
- 签名算法。



### 如何基于JWT进行身份验证

1. 用户向服务器发送用户名、密码以及验证码用于登陆系统。

2. 如果用户用户名、密码以及验证码校验正确的话，服务端会返回已经签名的 Token，也就是 JWT。

3. 用户以后每次向后端发请求都在 Header 中带上这个 JWT 。

4. 服务端检查 JWT 并从中获取用户相关信息。



### 如何防止JWT被创篡改

**即使JWT被拦截，也无法被篡改。**

这是为什么呢？因为服务端拿到 JWT 之后，会解析出其中包含的 Header、Payload 以及 Signature 。服务端会根据 Header、Payload、密钥再次生成一个 Signature。拿新生成的 Signature 和 JWT 中的 Signature 作对比，如果一样就说明 Header 和 Payload 没有被修改。

不过，如果服务端的秘钥也被泄露的话，黑客就可以同时篡改 Signature、Header、Payload 了。黑客直接修改了 Header 和 Payload 之后，再重新生成一个 Signature 就可以了。

所以要保管好秘钥才行



### JWT的优点

1. **无状态：**JWT 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 Session 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。
2. **避免了CSRF攻击：**CSRF 攻击需要依赖 Cookie ，Session 认证中 Cookie 中的 `SessionID` 是由浏览器发送到服务端的，只要发出请求，Cookie 就会被携带。借助这个特性，即使黑客无法获取你的 `SessionID`，只要让你误点攻击链接，就可以达到攻击效果。
3. **适合移动端应用：**使用 Session 进行身份认证的话，需要保存一份信息在服务器端，而且这种方式会依赖到 Cookie（需要 Cookie 保存 `SessionId`），所以不适合移动端。



### 如何解决JWT无状态所带来的问题？

1. **将 JWT 存入内存数据库**，如果不需要直接删除就可以了。
2. **黑名单机制**
3. **修改密钥 (Secret)** :
4. **保持令牌的有效期限短并经常轮换**



### JWT续签问题

1. 假设服务端给的 JWT 有效期设置为 30 分钟，服务端每次进行校验时，如果发现 JWT 的有效期马上快过期了，服务端就重新生成 JWT 给客户端。客户端每次请求都检查新旧 JWT，如果不一致，则更新本地的 JWT。
2. 每次请求都返回一个新的
3. **JWT 有效期设置到半夜**：可以保证大部分用户白天可以正常登录。
4. **用户登录返回两个 JWT**



## OAuth2.0

主要用来授权第三方应用获取有限的权限，它的最终目的是为第三方应用颁发一个有时效性的令牌 Token，使得第三方应用能够通过该令牌获取相关的资源。

OAuth 2.0 比较常用的场景就是第三方登录，当你的网站接入了第三方登录的时候一般就是使用的 OAuth 2.0 协议。



以往的授权方式不同之处是OAUTH的授权不会使第三方触及到用户的帐号信息（如用户名与密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此OAUTH是安全的。oAuth是Open Authorization的简写。

