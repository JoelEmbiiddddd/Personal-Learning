# 高并发系统设计

应对高并发大流量的方法就三种：

1. 横向扩展，分而治之。
2. 缓存：通过缓存来提高系统的性能。
3. 异步：未处理完成之前我们可以让请求先返回，在数据准备好之后再通知请求方。



### 高并发

而高并发系统的设计目标就是

1. 高性能
2. 高可用
3. 可扩展



**性能的度量标准**

1. 平均值，平均的响应时间。
2. 最大值，响应时间最长的值
3. 分位置，前90%的响应时间是多少等等。



### 高可用

**可用性度量标准：**

1. 平均故障间隔，即两次故障的间隔时间。
2. 故障的平均恢复时间，即平均故障时间。



## 数据库



### 池化技术

优点：核心思想就是空间换时间，通过预先创建好的对象来减少创建对象的性能开销，还可以对对象进行管理，降低使用成本。

缺陷：存储对象会消耗多余的内存，如果没有被频繁的使用就会造成内存上的浪费。



**需要注意的是**

1. 池子的最大值和最小值的设置很重要。
2. 池子中的对象需要在使用之前预先初始化完成，这叫做池子的预热，比方说使用线程池时就需要预先初始化所有的核心线程。如果池子未经过预热可能会导致系统重启后产生比较多的慢请求。



### 主从复制

主从复制依赖于binlog，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上二进制日志文件。主从复制就是将 binlog 中的数据从主库传输到从库上，一般这个过程是异步的，即主库上的操作不会等待 binlog 同步的完成。



**主从复制会出现的问题：**

1. 主库上 binlog 还没有来得及刷新到磁盘上就出现了磁盘损坏或者机器掉电，就会导致 binlog 的丢失，最终造成主从数据的不一致。
2. **无限制地增加从库的数量就可以抵抗大量的并发呢？** 那么连接到主库的从库IO数量就会很多，主库同样也需要创建同样多的线程来处理复制请求，对主库的资源消耗比较高，同时也会受限于带宽问题。所以一般建议是3~5个即可。
3. 主从延迟问题导致系统某些情况无法读取到最新保存的数据。



### 分库分表

在面对数据库容量瓶颈和写并发量大的问题时，你可以采用垂直拆分和水平拆分来解决

缺点：列表总数冗余，存储问题。



## 缓存

需要考虑三个问题



1. 如何选择缓存读写策略？
2. 缓存如何做到高可用？
3. 缓存穿透怎么办？缓存雪崩怎么办？



## 消息队列

三个作用：

1. 削峰填谷，**主要用途**
2. 异步处理
3. 解耦合，提高鲁棒性。



**秒杀场景，使用消息队列的话，怎么保证秒杀产品不超卖？**

主要有两种方法：

- 使用锁的方式，比如分布式锁，也可以利用 redis 本身操作原子性的特点
- 写入消息队列，在消息队列中做减库存的操作，做异步校验

**如何保证消息仅仅被消费一次？**



**如何保证消息不被重复消费？**



**如何提升消费性能保证更短的消息延迟呢？**



## 分布式服务



