## Java序列化



**序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。**



**常用场景：**

1. 对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；
2. 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；
3. 将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；
4. 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。



### JDK自带的序列化 serializable接口



不支持跨语言调用

性能差

存在安全问题



### Kryo



### Protobuf

Protobuf 出自于 Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。



### ProtoStuff

protostuff 基于 Google protobuf，但是提供了更多的功能和更简易的用法。



### Hessian

Hessian 是一个轻量级的，自定义描述的二进制 RPC 协议。





## Java反射机制

反射就是把java类中的各种成分映射成一个个的Java对象。比如说一个类里边有成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象



### Java反射机制的原理？描述一下反射机制是什么？

1. **一个 `Class` 对象对应一个加载到 JVM 中的一个 `.class` 文件**。
2. 首先 JVM 会将你的代码编译成一个 `.class` 字节码文件，然后被[类加载器](https://www.zhihu.com/search?q=类加载器&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2258328997})（Class Loader）加载进 JVM 的内存中，**同时会创建一个 `Date` 类的 `Class` 对象存到堆中**（注意这个不是 new 出来的对象，而是类的类型对象）。JVM 在创建 `Date` 对象前，会先检查其类是否加载，寻找类对应的 `Class` 对象，若加载好，则为其分配内存，然后再进行初始化 `new Date()`。
3. 堆内存的方法区就产生了一个 `Class` 对象，这个对象就包含了完整的类的结构信息，**我们可以通过这个 `Class` 对象看到类的结构**，就好比一面镜子。



### 作用，应用场景是什么？

1. SpringBoot、Spring，MyBatis中也运用了大量的反射机制。
2. 动态代理的实现也依赖于反射。
3. Java的注解也用到了反射。



## Java 代理模式

代理就是为另一个对象提供一个替身或占位符以控制对这个对象的访问



### 动态代理是什么？

在程序运行期间，创建目标代理对象，并在运行期间，对象中方法的动态拦截，在拦截方法的前后执行功能操作。



#### cglib

cglib是一个开源的包，他的具体实现方法就是

1. 导入cglib依赖包。
2. 代理类实现 **MethodInterceptor**。
3.  使用 **Enhance**类得到动态代理的实例。

#### Javassist

javassist是一个字节码指令库，利用javassist可以修改.class文件的结构，以实现对类的修改和创建。比如Dubbo中的动态代理所使用的就是javassit。



### JDK的代理

JDK代理自动生成的class是由sun.misc.ProxyGenerator来生成的。

1：显示Invokhandler接口

2：使用Proxy类生成代理类对象

3：利用反射执行代理类的指定方法



第一步：（把冰箱门打开）准备工作，将所有方法包装成ProxyMethod对象，包括Object类中hashCode、equals、toString方法，以及被代理的接口中的方法

第二步：（把大象装进去）为代理类组装字段，构造函数，方法，static初始化块等

第三步：（把冰箱门带上）写入class文件



### JDK和cglib的区别

JDK动态代理和CGLIB字节码生成的区别？

1. JDK动态代理只能对实现了接口（注意必须有接口）的类生成代理，而不能针对类
2. CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。因为是继承，所以该类或方法最好不要声明成final
3. cglib效率比JDK动态代理要差一点点，具体原因后面分析底层的实现的时候讲解

 在Spring aop中使用了JDK动态代理和cglib，使用情况是，如果实现了接口则使用JDK动态代理，如果没有实现接口则使用cglib。





## BigDecimal

为了避免精度丢失，可以使用 `BigDecimal` 来进行浮点数的运算



### 为什么`float`和`double`运算的时候会有精度丢失的风险

我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况



创建的时候，推荐使用`BigDecimal(String val)` 或者 `BigDecimal.valueOf(double val)`



等值比较问题中，应该使用 `compareTo()` 而不是 `equals()`



## Java 魔法类Unsafe

提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等。 这就类似于C语言中的指针，增加了程序发生相关指针问题的风险。

本地方法使用 **`native`** 关键字修饰，Java 代码中只是声明方法头，具体的实现则交给 **本地代码**。



## 泛型



### 为什么会引入泛型？

泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。

**为什么要使用泛型方法呢**？因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。





### super和extends的区别

<? extends E>extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类。

 <? super E>super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类。



## Java SPI机制

Java SPI机制是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦。



### 应用场景

1. JDBC：比如说很多数据库厂商会提供他们数据库的接口，可以直接使用SPI扩展来加载具体的驱动。JDBC的接口定义是java.sql.Driver，但没有具体实现，由不同厂商来实现。
2. 插件体系：比如说网关的shenyu，以及我们自己的网关，也使用到了这种SPI的插件体系。
3. Spring中的SPI机制：
4. 在springboot的自动装配过程中，最终会加载`META-INF/spring.factories`文件，而加载的过程是由`SpringFactoriesLoader`加载的。从CLASSPATH下的每个Jar包中搜寻所有`META-INF/spring.factories`配置文件，然后将解析properties文件，找到指定名称的配置后返回。



### 实现流程





**规范：**

1. 文件名一定要是接口的全类名



## Java异常类



### 异常的层次结构

### Throwable

Throwable 是 Java 语言中所有错误与异常的超类。Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。

1. **Error：**程序中无法处理的错误，表示运行应用程序中出现了严重的错误。此类错误一般表示代码运行时 JVM 出现问题。
2. **Exception：**程序本身可以捕获并且可以处理的异常。Exception异常同时分为了两类
   - 运行时异常：这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。
   - 非运行时异常：程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。



### 异常的关键字

1. **try：**用于监听，看看是否有异常抛出。
2. **catch：**捕获异常。
3. **finally：**不论是否捕获到异常，都会执行。主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。
4. **throw** – 用于抛出异常。遇到适合的就会抛出。
5. **throws** – 用在方法签名中，用于声明该方法可能抛出的异常。



### 常见的运行异常

1. 数组索引越界异常。
2. 空指针异常。
3. 数组长度为负异常
4. 非法参数异常。