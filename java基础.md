## Java序列化



**序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。**



**常用场景：**

1. 对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；
2. 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；
3. 将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；
4. 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。



### JDK自带的序列化 serializable接口



不支持跨语言调用

性能差

存在安全问题



### Kryo



### Protobuf

Protobuf 出自于 Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。



### ProtoStuff

protostuff 基于 Google protobuf，但是提供了更多的功能和更简易的用法。



### Hessian

Hessian 是一个轻量级的，自定义描述的二进制 RPC 协议。





## Java反射机制



`Spring`中的一个`@Component`注解就声明了一个类为Spring bean。 也可以通过`@Value`注解就读取到配置文件中的值。都是基于反射分析类，然后获取到类/属性/方法/方法参数上的注解。



## Java代理模式





## BigDecimal

为了避免精度丢失，可以使用 `BigDecimal` 来进行浮点数的运算



### 为什么`float`和`double`运算的时候会有精度丢失的风险

我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况



创建的时候，推荐使用`BigDecimal(String val)` 或者 `BigDecimal.valueOf(double val)`



等值比较问题中，应该使用 `compareTo()` 而不是 `equals()`



## Java 魔法类Unsafe

提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等。 这就类似于C语言中的指针，增加了程序发生相关指针问题的风险。

本地方法使用 **`native`** 关键字修饰，Java 代码中只是声明方法头，具体的实现则交给 **本地代码**。





## Java SPI机制

专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦。



### 具体流程

1. 每次类加载的时候会先去找到 class 相对目录下的 `META-INF` 文件夹下的 services 文件夹下的文件，将这个文件夹下面的所有文件先加载到内存中。
2. 根据文件名和里边的文件内容找到相对应接口的具体实现类
3. 找到实现类后生成对应的对象，保存在一个list列表中
4. 过迭代或者遍历的方式拿到对应的实例对象，生成不同的实现。



**规范：**

1. 文件名一定要是接口的全类名