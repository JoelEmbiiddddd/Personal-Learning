



### InnoDB是以什么单位来管理存储空间的：

 InnoDB 存储引擎是以页为单位来管理存储空间的。往 MySQL 插入的数据最终都是存在于页中的，准确点来说是数据页这种类型。

### NoSQL是什么

常见的代表有MongoDB、Redis

### Buffer pool是什么？

为了减少磁盘 IO 开销，还有一个叫做 Buffer Pool(缓冲池) 的区域，存在于内存中。当我们的数据对应的页不存在于 Buffer Pool 中的话， MySQL 会先将磁盘上的页缓存到 Buffer Pool 中，这样后面我们直接操作的就是 Buffer Pool 中的页，这样大大提高了读写性能。



### **MySQL 怎么保证原子性的？**

1. 如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行**回滚**，在 MySQL 中，恢复机制是通过 **回滚日志（undo log）** 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。

2. 这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚之前未完成的事务。

3. 如果执行过程中遇到异常的话，我们直接利用 **回滚日志** 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。

   

### MySQL的事务

**事务能否生效数据库引擎是否支持事务是关键。比如常用的 MySQL 数据库默认使用支持事务的 `innodb`引擎。但是，如果把数据库引擎变为 `myisam`，那么程序也就不再支持事务了！**



### MySQL存储引擎

- ### MySQL 支持哪些存储引擎？默认使用哪个？

- ### MyISAM 和 InnoDB 有什么区别？、

  - 行级锁
  - 外键
  - 事务
  - 支持数据库异常崩溃后的安全恢复
  - MVCC
  - 索引的实现



### MySQL中的事务是什么



### 并发事务带来的问题是什么

- 脏读
- 丢失修改
- 不可重读
- 幻读



### 并发事务的控制方式有哪些

- 锁
- MVCC



### SQL标准定义了哪些事务隔离级别

- 读取未提交
- 读取已提交
- 可重复读
- 可串行化



### MySQL 默认隔离级别是什么

可重复读



### 为什么MySQL采用B+树作为索引

我们在考虑这个问题的时候，除了从数据结构的角度出发外，还要从磁盘I/O操作次数，因为数据是存储在磁盘中的



磁盘读写的最小单位是**扇区**，扇区的大小只有 `512B` 大小，操作系统一次会读写多个扇区，所以**操作系统的最小读写单位是块（Block）。Linux 中的块大小为 `4KB`**，也就是一次磁盘  I/O 操作会直接读写 8 个扇区。



- 二分查找树： 在极端状态下，每次插入的元素都是树中最大的元素，那么二叉查找树就会退化成了一条链表，查找数据的时间复杂度变成了 O(n)。
- 自平衡二叉树：插入的时候，左子树要求不能高于右子树1层，反之一样。但是**不管平衡二叉查找树还是红黑树，都会随着插入的元素增多，而导致树的高度变高，这就意味着磁盘 I/O 操作次数多，会影响整体数据查询的效率**。
- B树：解决了I/O操作次数多的问题，但是 B 树的每个节点都包含数据（索引+记录），而用户的记录数据的大小很有可能远远超过了索引数据，这就需要花费更多的磁盘 I/O 操作次数来读到「有用的索引数据」。而且如果我要找最底层的数据，那么中间所经过的数据，从磁盘读取到内存中的资源就浪费了。
- B+树与B树的差异：
  - 叶子节点（最底部的节点）才会存放实际数据（索引+记录），非叶子节点只会存放索引；
  - 叶子节点之间构成了一个有序链表。
  - B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点
  - 非叶子节点中有多少个子节点，就有多少个索引；



思考方式就3个：

1. I/O操作次数：决定了树的高度是不能够高的，而B+树和B树能够满足要求。

2. 查询复杂度：为了支持范围查询以及关联关系， 页中数据需要有序，且页的尾部节点指向下个页的头部；

3. 对磁盘读取到内存的资源浪费程度：以页为单位读取使得一次 I/O 就能完全载入一个节点，且相邻的节点也能够被预先载入；所以数据放在叶子节点，本质上是一个Page页。

   

   



### 数据库三大日志



**redo log**

重做日志是InnoDB引擎特有的，当MySQL实例挂了或者宕机后，InnoDB就会用redo log恢复数据。



redo log中有一个很重要的点就是刷盘时机，一共有3个



在个**日志文件组**中还有两个重要的属性，分别是 `write pos、checkpoint`

- **write pos** 是当前记录的位置，一边写一边后移
- **checkpoint** 是当前要擦除的位置，也是往后推移



**为什么要有redo log，每次修改文件直接刷盘不就好了：**

性能非常差。最大的问题就是 InnoDB 页的大小一般为 16KB，而页又是磁盘和内存交互的基本单位。这就导致即使我们只修改了页中的几个字节数据，一次刷盘操作也需要将 16KB 大小的页整个都刷新到磁盘中。而且，这些修改的页可能并不相邻，也就是说这还是随机 IO。



redo log的性能非常好。首先，redo log 的写入属于顺序 IO。 其次，一行 redo log 记录只占几十个字节。



**binlog**

`redo log` 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 `InnoDB` 存储引擎。

而 `binlog` 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于`MySQL Server` 层。



不管用什么引擎，都存在有binlog



写入机制： 

事务执行过程中，先把日志写到`binlog cache`，事务提交的时候，再把`binlog cache`写到`binlog`文件中。



**两阶段提交**

redo log主要是保证崩溃恢复的能力

binlog主要是保证MySQL集群的数据一致性

执行更新语句过程，会记录`redo log`与`binlog`两块日志，以基本的事务为单位，`redo log`在事务执行过程中可以不断写入，而`binlog`只有在提交事务时才写入，所以`redo log`与`binlog`的写入时机不一样。这时候就会出现问题

为此，MySQL将redo log拆为两个阶段： prepare和commit



**undo log**

保证的是数据的原子性





## InnoDB对MVCC的实现



### 一致性非锁定读和快照读

常做法是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。在InnoDB中，多版本控制就是对非锁定读的实现。

如果读取的行正在执行 `DELETE` 或 `UPDATE` 操作，这时读取操作不会去等待行上锁的释放。相反地，`InnoDB` 存储引擎会去读取行的一个快照数据，对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)。

如果是在**读取已提交**或者是 **可重复读** 两个隔离级别下，执行普通的select，则会使用MVCC。



### 锁定读

如果执行以下指令，就会执行锁定读：

- `select ... lock in share mode`
- `select ... for update`
- `insert`、`update`、`delete` 操作



第一个是对记录加锁，后两个是加x锁



注意的是：在一致性非锁定读下，即使读取的记录已被其它事务加上 `X` 锁，这时记录也是可以被读取的，即读取的快照数据。



### InnoDB对MVCC的实现

`MVCC` 的实现依赖于：**隐藏字段、Read View、undo log**。



**隐藏字段**

Innodb为每行数据添加了三个隐藏字段

- DB_TRX_ID(6 b): 表示最后一次插入或更新该行的事务 id。
- DB_ROLL_PTR（7 b）：回滚指针，指向该行的 `undo log` 。如果该行未被更新，则为空
- DB_ROW_ID（6 b）： 如果没有设置主键且该表没有唯一非空索引时，`InnoDB` 会使用该 id 来生成聚簇索引



**ReadView**

[`Read View`](https://github.com/facebook/mysql-8.0/blob/8.0/storage/innobase/include/read0types.h#L298) 主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务”



**undo log**

undo log有两个作用：

- 当事务回滚时用于将数据恢复到修改前的样子
- 另一个作用是 `MVCC` ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 `undo log` 读取之前的版本数据，以此实现非锁定读



同时 undo log分为insert log 和 update undo log（回滚链）



**可见性算法**

我们在执行select语句的时候，都会创建一个快照（Read View），**快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号**。会将记录里边一些参数进行比较，来判断是否满足可见性条件。



### RC和RR隔离级别下MVCC的差异

生成的read view的时机不同

- RC下，每次select查询前都生成一个read_view
- RR下，只在事务开始后，第一次select数据前生成一个read_view

这样子RR就解决了不可重复读的问题。



### MVCC + Next-key-lock防止幻读

InnoDB在RR级别下通过MVCC和Next-key-lock解决幻读。



## SQL语句在MySQL中执行



### MySQL基础架构

用户   -  连接器 - 分析器  - 优化器 - 执行器 - 存储引擎（提供读写接口）



中间几个叫作server层，最后一个称为存储引擎



### 语句分析

SQL语句可以分为两类，一类是查询，一类是更新



**查询语句**

1. 先查询该语句有无权限，没有则返回错误
2. 通过分析器进行词法分析，提取 SQL 语句的关键元素。
3. 优化器进行确定执行方案，选择一个它认为效率最高的一个方案
4. 进行权限验证，如果有权限就调用存储引擎接口，返回执行结果



**更新语句**

顺序和查询语句一样，但是在执行的时候多操作了两步

1. 写入更改的那行数据，innodb把数据存在内存中，同时记录redo log，redo log 进入prepare状态，告诉执行器它执行完了，随时可以提交。
2. 执行器收到命令后记录binlog，提交，redo log 更为提交状态。

这里的一个考点就是数据一致性。



## 优化SQL

优化SQL的第一步就是读懂SQL的执行计划，也就是EXPLAIN执行计划



### 获取EXPLAIN执行计划

EXPLAIN不会真正执行，而是通过查询器、优化器进行分析。



### 分析EXPLAIN的结果

这里边有很多字段，最重要的是`type`，描述了查询是如何执行的；`key`，表示 MySQL 实际使用到的索引。如果为 NULL，则表示未用到索引；`Extra`，包含了 MySQL 解析查询的额外信息。



## MySQL索引

1. 按数据结构划分：
   - BTree
   - 哈希
   - RTee
   - 全文
2. 按底层存储方式划分：
   - 聚簇索引：索引结构和数据一起存放的索引
   - 非聚簇索引：索引结构和数据分开存放的索引
3. 应用维度：
   - 主键索引（不可以有NULL）
   - 普通索引
   - 唯一索引（可以有NULL）
   - 联合索引



### 主键索引

一张数据表只能有一个主键，且不能为NULL

如果创建的时候没有主键索引，则InnoDB会自动创建一个6字节的自增索引作为主键。



### 二级索引

**通过二级索引，可以定位主键的位置。**



### 聚簇索引

**即索引结构和数据一起存放的索引**，InnoDB中的主键索引使用的就是聚簇索引。

对于InnoDB的索引表而言，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。

优点：

1. 查询速度快
2. 对排序查找和范围查找优化好

缺点：

1. 依赖于有序的数据
2. 更新代价大



### 非聚簇索引

非聚簇索引(Non-Clustered Index)即索引结构和数据分开存放的索引，**MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。**



### 覆盖索引和联合索引的区别

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为 **覆盖索引（Covering Index）** 。**覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询**



使用表中的多个字段创建索引，就是 **联合索引**，也叫 **组合索引** 或 **复合索引**。



### 索引优化

1. **前缀索引的优化：** 使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。
2. **覆盖索引的优化：** 多使用覆盖索引，不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。
3. **主键索引的优化：** 主键索引最好是自增的，因为每次**插入一条新记录，都是追加操作，不需要重新移动数据**。如果是非自增的，可能会造成页分裂，还可能会造成大量的内存碎片。
4. **索引最好设置为Not NULL**
5. **防止索引失效** 



### 索引失效

1. **对索引使用左或者左右模糊匹配：** 比如说like关键字，因为我们的索引B+树走的是前缀匹配，只根据前缀进行比较。
2. **对索引使用函数：**因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。
3. **对索引进行表达式计算：**原因跟对索引使用函数差不多。
4. **对索引隐式类型转化：** 有可能会对索引使用函数。
5. **联合索引非最左匹配：**因为B+树会进行最左匹配
6. **Where语句中存在有or**：如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。
7. **=，>=,<,>,<=这些比较符合也有可能会引起索引失效：** 这是因为如果Innodb发现全表扫描比索引扫描更快，那么就会使用全表扫描而不是索引扫描。



### 什么是索引下推

在MySQL5.6中更新了一个叫索引下推的功能，可以索引遍历中，先对索引段做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。

**原理是什么？**

截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 `(a, b, c)` 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。





### 什么时候适用于索引，什么时候不适用于索引

**适用于索引**

1. 字段有唯一性限制的，比如商品编码。
2. 经常使用`where`查询条件的字段，可以提高整个表的查询速度。
3. 经常使用`GROUP BY` 和 `ORDER BY`的字段。因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。



**不适用于索引**

1. `WHERE` 条件，`GROUP BY`，`ORDER BY` 里用不到的字段。
2. 字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀。会直接走全表扫描。
3. 表数据太少的时候，也不需要创建索引。
4. 经常更新的字段不用创建索引



## MySQL中时间类型数据存储



### 不要用字符串存储时间

1. 字符串占用的空间大
2. 字符串存储的日期效率比较低（逐个字符进行比对）



### DateTime和TimeStamp之间的抉择



一般都只会选择TimeStamp

1. **DateTime 类型是没有时区信息的（时区无关）**
2. **Timestamp 和时区有关**
3. DateTime占用的空间更大。 TimeStamp是4个，而DateTime是8个



## MySQL常见日志

常见的日志有：

### 错误日志（error log）

对MySQL的启动、运行、关闭过程进行了记录

### 二进制日志（binlog ）

主要记录了对 MySQL 数据库执行了更改的所有操作。更改表结构也会被写入binlog中。binlog 最主要的应用场景是 主从复制 ，主备、主主、主从都离不开binlog，需要依靠 binlog 来同步数据，保证数据一致性。



**binlog的格式有哪几种？**

- statement模式：每一条修改的sql语句都会被记录 inserts、updates、deletes。
- row模式：每一行的具体变更事件都会被记录在binlog中。
- Mixed 模式 ：Statement 模式和 Row 模式的混合。默认使用 Statement 模式，需要自行切换到row模型中。



相比较于 Row 模式来说，Statement 模式下的日志文件更小，磁盘 IO 压力也较小，性能更好有些。不过，其准确性相比于 Row 模式要差。



**主从复制**

1. 主数据库将数据变化写入到binlog中
2. 从库连接主库
3. 从库会创建一个I/O线程向主库请求更新的binlog
4. 主库会创建一个binlog dump 线程来发送binlog，从库中的I/O线程负责接收。
5. 从库的I/O线程将接收的binlog写入到relay log中。
6. 从库的SQL线程读取relay log 同步数据本地。



**binlog刷盘时机**

事务在执行过程中，会先把日志写入到binlog cache中，只有在事务提交的时候，才会把binlog cache中的日志持久化到磁盘上的binlog文件中。写入内存的速度更快，这样做也是为了效率考虑。

binlog刷到磁盘中的时机可以通过 `sync参数来控制：` 范围是0~N：

- 0：不强制，由系统自行判断何时写入到磁盘中；
- 1：每次提交都写入到磁盘中。
- N：N个事务一起提交到磁盘中。



通常情况下，不建议将  sync_binlog 的值设置为 0 。如果对性能要求比较高或者出现磁盘 IO 瓶颈的话，可以适当将sync_binlog 的值调大，不过，这样会增加数据丢失的风险。



**什么情况下会重新生成binlog日志：**

1. 数据库重启。
2. 使用flush logs命令。
3. binlog超过最大阈值的时候。



### 一般查询日志

已建立连接的客户端发送给 MySQL 服务器的所有 SQL 记录，因为 SQL 的量比较大，默认是不开启的，也不建议开启。

### 慢查询日志（slow query log）

 执行时间超过 long_query_time秒钟的查询，解决SQL慢查询问题时候会用到。默认是10s，一般是1s。找到慢 SQL 是优化 SQL 语句性能的第一步，然后再用EXPLAIN 命令可以对慢 SQL 进行分析，

### 事务日志（redo log 和 undo log）



**redo log 如何保证事务的持久性：**

redo log 主要做的事情就是记录页的修改，比如某个页面某个偏移量处修改了几个字节的值以及具体被修改的内容是什么。redo log 中的每一条记录包含了表空间号、数据页号、偏移量、具体修改的数据，甚至还可能会记录修改数据的长度



1.先将原始数据从磁盘读入内存（缓冲池 Buffer pool），事务发生时，会修改内存中的拷贝，此时还未写入磁盘
2.生成redo日志，写入redo log buffer
3.当事务commit之后，以一定的频率 （innodb_flush_log_at_trx_commit也就是刷盘策略）写入redo log file（在磁盘中）
4.innodb_flush_log_at_trx_commit
设置 0 不刷盘，操作系统默认每1秒进行同步
                                   1 事务提交就刷盘（其实就是写入PageCache 立即刷盘 写入redo log file ）
                                    2 事务提交将redo log buffer写入PageCache  每秒刷新一次到磁盘
5.redo log file里有个checkpoint（之前都写入磁盘），write pos（写入位置）保证事物的持久性 



### 中继日志（relay log）

relay log 是复制过程中产生的日志，很多方面都跟 binary log 差不多。不过，relay log 针对的是主从复制中的从库。

### DDL日志

DDL语句执行的元数据操作。



