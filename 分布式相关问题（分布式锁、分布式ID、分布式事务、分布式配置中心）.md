## Raft算法



### 共识算法是什么？

共识是可容错系统中的一个基本问题：即使面对故障，服务器也可以在共享状态上达成一致。也就是说，共识算法的工作就是保持复制日志的一致性



### 在Raft集群中，节点类型都有哪些？

在任意时间内，每台机器一定会处于三个状态中的一个：

1. Leader：负责发起心跳，响应客户端，创建日志，同步日志。
2. Candidate：Leader选举过程中的临时角色。
3. Follower：接受 Leader 的心跳和日志同步数据，投票给 Candidate。

正常的情况下，只有一个服务器是 Leader，剩下的服务器是 Follower。Follower不会发送任何请求。



### 任期是什么？

1. Raft算法会把时间划分为任意长度的任期（term）。
2. 每个节点都会存储当前的 term 号，当服务器之间进行通信时会交换当前的 term 号。
3. 如果有服务器发现自己的 term 号比其他人小，那么他会更新到较大的 term 值。
4. 如果一个 Candidate 或者 Leader 发现自己的 term 过期了，他会立即退回成 Follower。



### 日志是什么组成？

`entry：`  每个事件都是entry，只有Leader可以创建entry，entry里边包含有<index,term,cmd>，cmd是应用到状态机上的指令。

`log：` 由 entry 构成的数组，每一个 entry 都有一个表明自己在 log 中的 index。



entry 总是先被 Leader 添加到自己的 log 数组中，然后再发起共识请求，获得同意后才会被 Leader 提交给状态机。Follower 只能从 Leader 获取新日志和当前的 commitIndex，然后把对应的 entry 应用到自己的状态机中。



### 领导人选举

raft 使用心跳机制来触发 Leader 的选举。Leader 会向所有的 Follower 周期性发送心跳来保证自己的 Leader 地位。如果一个 Follower 在一个周期内没有收到心跳信息，就叫做选举超时，然后它就会认为此时没有可用的 Leader，并且开始进行一次选举以选出一个新的 Leader。

选举过程：

1. Follower会自增自己的term号，将状态转化为Candidate。然后向所有节点发起选举请求。
2. 在 Candidate 等待选票的时候，它可能收到其他节点声明自己是 Leader 的心跳，此时有两种情况：
   - 这个Leader的term号大于等于自己的term号，说明对方成为了Leader，自己退回Follower
   - 小于，则拒绝并让这个节点更新term号。



由于可能同一时刻出现多个 Candidate，导致没有 Candidate 获得大多数选票。对此，raft算法中采用选举超时时间来避免，都会随机化一个新的枚举超时时间，这种机制使得各个服务器能够分散开来。



**选举超时就是新一轮选举开始时，每个节点随机思考要不要做领导者的时间，这个时间一般100-到200ms，非常短。在这个时间内，节点必须等待，不能成为Candidate状态**



### 日志复制

当我们选举出Leader后，就会开始接受客户端的请求。

1. Leader收到客户端的请求后，会生成一个entry，包含有<index,term,cmd>，再将entry添加到自己的日志最后，向所有的节点广播。
2. 如果 Follower 接受该 entry，则会将 entry 添加到自己的日志后面，同时返回给 Leader 同意。
3. 如果 Leader 收到了多数的成功响应，Leader 会将这个 entry 应用到自己的状态机中，之后可以成为这个 entry 是 committed 的，并且向客户端返回执行结果。



### Raft一致不一致情况怎么处理

在Raft中，我们要保证两个性质：

1. 在两个日志中，有两个entry拥有相同的term和index，那么他一定拥有相同的cmd
2. 在两个日志中，有两个entry拥有相同的term和index，那么他们前面的entry一定相同。



对于第一个性质，我们是通过 “仅有Leader可以生成entry”来保证。

对于第二个性质，就需要一致性检测来保证：为了使得 Follower 的日志和自己的日志一致，Leader 需要找到 Follower 与它日志一致的地方，然后删除 Follower 在该位置之后的日志，接着把这之后的日志发送给 Follower。

Leader会给每个followers维护一个nextIndex，然后每次消息传递来就会增1，如果发现不一致就会删除，然后把之后的信息发送过来。





## Gossip协议

分布式系统中，不同节点之间进行数据/信息共享一般是用集中发散消息。但是有很明显的缺点：

1. 节点多的时候同步慢
2. 依赖于中心节点，存在单点风险的问题。



在 Gossip 协议下，没有所谓的中心节点，每个节点周期性地随机找一个节点互相同步彼此的信息，理论上来说，各个节点的状态最终会保持一致。

下面我们来对 Gossip 协议的定义做一个总结：**Gossip 协议是一种允许在分布式系统中共享状态的去中心化通信协议，通过这种通信协议，我们可以将信息传播给网络或集群中的所有成员**。



### 应用

1. Redis Cluster： Redis Cluster 就是基于 Gossip 协议来实现集群中各个节点数据的最终一致性。
2. Consul





## 分布式ID

什么是分布式ID

比如说分库分表，如果是单机的话可以用MySQL的自增主键。但是如果数据分布在不同服务器上，那么数据库的自增主键就没办法满足生成的主键唯一性了。

一个分布式ID应该满足：

1. 全局唯一
2. 高性能，对本地资源消耗少
3. 高可用
4. 方便易用。



### 数据库分布式ID

数据库主键自增这种模式，每次获取 ID 都要访问一次数据库，ID 需求比较大的时候，肯定是不行的。那么我们可以使用数据库号段模式，批量获取，然后保存在内存中，需要用的时候再拿出来。

如果我们可以批量获取，然后存在在内存里面，需要用到的时候，直接从内存里面拿就舒服了！这也就是我们说的 **基于数据库的号段模式来生成分布式 ID。**





### 为什么不常使用UUID

UUID包含32个16进制数字，UUID 可以保证唯一性，因为其生成规则包括 MAC 地址、时间戳、名字空间（Namespace）、随机。但很少去用他。

比如使用 UUID 作为 MySQL 数据库主键的时候就非常不合适：

- 数据库主键要尽量越短越好，而 UUID 的消耗的存储空间比较大（32 个字符串，128 位）。
- UUID 是无顺序的，InnoDB 引擎下，数据库主键的无序性会严重影响数据库性能。



### 雪花算法

Snowflake 是 Twitter 开源的分布式 ID 生成算法。Snowflake 由 64 bit 的二进制数字组成，这 64bit 的二进制被分成了几部分。

1. 第0位：符号位
2. 第1~41位：用来表示时间戳，单位为毫秒。
3. 第42~52位。用10位来表示，用来区分不同集群/机房的节点，比如说前5位表示机房ID，后5位表示机器ID。
4. 第53~64位。用来表示序列号。 序列号为自增值，代表单台机器每毫秒能够产生的最大 ID，



### 雪花算法开源框架



**Leaf**

滴滴的Tiny





## 分布式锁

对于单机多线程来说，在 Java 中，我们通常使用 `ReetrantLock` 类、`synchronized` 关键字这类 JDK 自带的 **本地锁** 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。



一个最基本的分布式锁需要满足：

1. 互斥
2. 高可用
3. 可重入

通常情况下，我们一般会选择基于 Redis 或者 ZooKeeper 实现分布式锁。



## 基于Redis实现分布式锁

在Redis中，SetNX命令可以帮助我们实现互斥。为了防止误删到其他的锁，这里我们建议使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。

选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。

存在的问题：

​    应用程序遇到一些问题比如释放锁的逻辑突然挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程/进程访问。

对此，我们可以给锁设置时间 expire：

**如果操作共享资源的时间大于过期时间，就会出现锁提前过期的问题，进而导致分布式锁直接失效。**



### Redission：实现自动续期

Redisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，不仅仅包括多种分布式锁的实现。

Redisson 中的分布式锁自带自动续期机制，使用起来非常简单，原理也比较简单，其提供了一个专门用来监控和续期锁的 **Watch Dog（ 看门狗）**，如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。

1. 默认情况为，每过10s，看门狗就会执行续期操作，将锁的超时时间设置为 30 秒。看门狗续期前也会先判断是否需要执行续期操作，需要才会执行续期，否则取消续期操作。



### Redission：实现可重入锁

**Redisson** 中，其内置了多种类型的锁比如可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）。



### Redis如何解决集群情况下分布式锁的可靠性

在集群下，Redission会出现问题，比如说：由于 Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。

Redlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。

但Redlock 实现比较复杂，性能比较差，发生时钟变迁的情况下还存在安全性隐患。不推荐使用。



## 基于ZooKeeper实现分布式锁

Redis 实现分布式锁性能较高，ZooKeeper 实现分布式锁可靠性更高。

ZooKeeper 分布式锁是基于 **临时顺序节点** 和 **Watcher（事件监听器）** 实现的。

获取锁：

1. 
